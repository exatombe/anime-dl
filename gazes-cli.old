#!/bin/bash

reset="\e[0m"
bg_cyan="\e[46m"
fg_white="\e[97m"
fg_black="\e[30m"

subcommand=$1
pids=()

update_playlist() {
  local playlist_path="./$anime_title/playlist.m3u8"
  local episode_file_path="./$anime_title/$episode_num.mp4"

  echo "#EXTM3U" >"$playlist_path" # Create a new playlist if not exists or reset the old one
  for ep_file in $(ls ./$anime_title/*.mp4 | sort -V); do
    echo "$ep_file" >>"$playlist_path"
  done
}

cleanup() {
  echo "Cleaning up..."
  kill "${pids[@]}" >/dev/null 2>&1
  stop_spinner
  echo "All processes should be terminated now."
  echo -e "${reset}Exiting gracefully."
  exit 1
}

trap 'cleanup' SIGINT SIGTERM

error() {
  echo -e "  \033[48;2;255;0;0m Error ${reset}\033[38;2;255;0;0m $1"
}

code_block() {
  echo -e "\e[48;2;18;23;28m\e[38;2;89;116;143m $1 \e[0m"
}

print_usage() {
  echo
  echo -e "  ${bg_cyan}${fg_black} Usage ${reset} $0 $(code_block "download | watch")"
  echo
}

if [[ $subcommand != "download" ]] && [[ $subcommand != "watch" ]]; then
  print_usage
  exit 1
fi

if [[ -z $subcommand ]]; then
  print_usage
  exit 1
fi

api="https://api.gazes.fr/anime"

# download
getAnime() {
  local result=$(curl -s "${api}/animes" | jq -r .data)
  local title=$(echo "$result" | jq -r '.[].title' | fzf | sed 's/"/\\"/g')

  if [[ -z $title ]]; then
    exit
  fi

  local anime=$(echo "$result" | jq -r ".[] | select(.title == \"$title\")")
  local anime_id=$(echo "$anime" | jq -r ".id")
  anime=$(curl -s "${api}/animes/${anime_id}")

  echo $anime
}

start_spinner() {
  gum spin --spinner dot --title "Downloading..." -- sleep infinity &
  spinner_pid=$!
}

stop_spinner() {
  kill $spinner_pid
  wait $spinner_pid 2>/dev/null
}

download() {
  local anime=$(getAnime)

  if [[ -z $anime ]]; then
    error "Please select an anime"
    exit 1
  fi

  local anime_id=$(echo "$anime" | jq -r ".data.id")
  local anime_title=$(echo "$anime" | jq -r ".data.title")
  local selected_episodes=$(echo "$anime" | jq -r ".data.episodes[].title" | gum choose --no-limit --header "Choose episodes to download")

  if [[ -z $selected_episodes ]]; then
    error "You must select at least one episode"
    exit 1
  fi

  local lang=$(gum choose --height 4 --header "Language" {vf,vostfr})

  if [[ -z $lang ]]; then
    error "Language selection required"
    exit 1
  fi

  IFS=$'\n' read -r -d '' -a episodes <<<"$selected_episodes"

  for episode in "${episodes[@]}"; do
    (
      local episode_num=$(echo "$anime" | jq -r ".data.episodes[] | select(.title == \"$episode\") | .num")
      local episode_full=$(curl -s "${api}/animes/${anime_id}/${episode_num}")
      local episode_url=$(echo "$episode_full" | jq -r ".data.${lang}.videoUri // .data.vostfr.videoUri")

      if curl --output /dev/null --silent --head --fail "$episode_url"; then
        local tmp_folder="./$anime_title/$episode_num.mp4"
        mkdir -p "$(dirname "$tmp_folder")"

        if ffmpeg -loglevel error -i "$episode_url" -c copy "$tmp_folder"; then
          update_playlist "$anime_title" "$episode_num"
        else
          echo "Failed to download episode $episode_num."
        fi
      else
        echo "Episode URL $episode_url not accessible."
      fi
    ) &
    pids+=($!)
  done

  start_spinner
  wait "${pids[@]}"
  stop_spinner

  echo "Download completed."
}

case "$1" in
download)
  download
  ;;
esac
