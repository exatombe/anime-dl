#!/bin/bash

api="https://api.gazes.fr/anime"
pids=()
vlc_password="your_vlc_password" # Set your VLC password here

cleanup() {
  echo "Cleaning up..."
  if [[ -n "${pids[*]}" ]]; then
    kill "${pids[@]}" >/dev/null 2>&1
  fi
  stop_spinner
  if [[ -n "$vlc_pid" ]]; then
    kill $vlc_pid >/dev/null 2>&1
  fi
  echo "All processes should be terminated now."
  echo "Exiting gracefully."
  exit 1
}

trap 'cleanup' SIGINT SIGTERM
start_spinner() {
  local message="Downloading $total_episodes episodes..."
  gum spin --spinner dot --title "$message" -- sleep infinity &
  spinner_pid=$!
}

stop_spinner() {
  kill $spinner_pid
  wait $spinner_pid 2>/dev/null
}

get_anime() {
  local result=$(curl -s "${api}/animes" | jq -r .data)
  local title=$(echo "$result" | jq -r '.[].title' | fzf)

  if [[ -z $title ]]; then
    exit 1
  fi

  local anime=$(echo "$result" | jq -r ".[] | select(.title == \"$title\")")
  local anime_id=$(echo "$anime" | jq -r ".id")
  anime=$(curl -s "${api}/animes/${anime_id}")

  echo "$anime"
}

sanitize_filename() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]_-' | tr ' ' '_'
}

download_episode() {
  local anime_title="$1"
  local episode_num="$2"
  local episode_url="$3"
  local folder="$4"

  local sanitized_title=$(sanitize_filename "$anime_title")
  local output_file="$folder/$sanitized_title/episode_${episode_num}.mp4"
  mkdir -p "$folder/$sanitized_title"

  if ffmpeg -loglevel error -i "$episode_url" -c copy "$output_file"; then
    echo "Downloaded episode $episode_num successfully."
    update_playlist "$folder" "$sanitized_title"
  else
    echo "Failed to download episode $episode_num."
  fi
}

update_playlist() {
  local folder="$1"
  local anime_title="$2"
  local playlist_path="$folder/$anime_title/playlist.m3u8"

  echo "#EXTM3U" >"$playlist_path"
  for ep_file in $(ls "$folder/$anime_title"/*.mp4 | sort -V); do
    realpath "$ep_file" >>"$playlist_path"
  done
}

create_playlist() {
  local folder="$1"
  local playlist_path="$folder/playlist.m3u8"

  if [[ ! -d $folder ]]; then
    echo "Folder '$folder' does not exist."
    exit 1
  fi

  echo "#EXTM3U" >"$playlist_path"
  for ep_file in $(ls "$folder"/*.mp4 | sort -V); do
    realpath "$ep_file" >>"$playlist_path"
  done

  echo "Playlist created at $playlist_path"
}

download() {
  local folder="${2:-.}" # Default to current directory if folder not specified
  local anime=$(get_anime)

  if [[ -z $anime ]]; then
    echo "Please select an anime"
    exit 1
  fi

  local anime_id=$(echo "$anime" | jq -r ".data.id")
  local anime_title=$(echo "$anime" | jq -r ".data.title" | sed 's/"/\\"/g')
  local selected_episodes=$(echo "$anime" | jq -r ".data.episodes[].title" | gum choose --no-limit --header "Choose episodes to download")

  if [[ -z $selected_episodes ]]; then
    echo "You must select at least one episode"
    exit 1
  fi

  local lang=$(gum choose --height 4 --header "Language" {vf,vostfr})

  if [[ -z $lang ]]; then
    echo "Language selection required"
    exit 1
  fi

  IFS=$'\n' read -r -d '' -a episodes <<<"$selected_episodes"

  total_episodes=${#episodes[@]}

  start_spinner

  for episode in "${episodes[@]}"; do
    (
      local episode_num=$(echo "$anime" | jq -r ".data.episodes[] | select(.title == \"$episode\") | .num")
      local episode_full=$(curl -s "${api}/animes/${anime_id}/${episode_num}")
      local episode_url=$(echo "$episode_full" | jq -r ".data.${lang}.videoUri // .data.vostfr.videoUri")

      if curl --output /dev/null --silent --head --fail "$episode_url"; then
        download_episode "$anime_title" "$episode_num" "$episode_url" "$folder"
      else
        echo "Episode URL $episode_url not accessible."
      fi
    ) &
    pids+=($!)
  done

  wait "${pids[@]}"
  stop_spinner

  echo "Download completed."
}

print_usage() {
  echo "Usage: $0 download|playlist|watch [folder]"
  exit 1
}

watch_anime() {
  local folder="${1:-.}" # Default to current directory if folder not specified
  local anime_progress_file="$folder/progress.txt"

  if [[ ! -f $anime_progress_file ]]; then
    echo "No progress file found in $folder. Creating a new one."
    echo "1" >"$anime_progress_file"
    echo "0" >>"$anime_progress_file"
  fi

  local episode_num=$(sed -n '1p' "$anime_progress_file")
  local time_pos=$(sed -n '2p' "$anime_progress_file")

  local episode_file="$folder/episode_${episode_num}.mp4"

  if [[ ! -f $episode_file ]]; then
    echo "Episode file $episode_file not found."
    exit 1
  fi

  echo "Resuming episode $episode_num at $time_pos seconds."

  # Start VLC with HTTP interface enabled
  vlc --extraintf http --http-password "$vlc_password" --start-time="$time_pos" "$episode_file" >"$folder/vlc.log" 2>&1 &
  vlc_pid=$!

  echo "VLC started with PID $vlc_pid."

  while :; do
    sleep 10
    if curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json" | jq -e . >/dev/null 2>&1; then
      time_pos=$(curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json" | jq -r .time)
      if [[ -n "$time_pos" ]]; then
        save_progress "$folder" "$episode_num" "$time_pos"
      else
        echo "Failed to get time position from VLC."
      fi
    else
      echo "Unable to connect to VLC HTTP interface. VLC might not have started properly."
      break
    fi

    # Check if VLC is still running
    if ! kill -0 $vlc_pid 2>/dev/null; then
      echo "VLC process has ended."
      break
    fi
  done

  wait $vlc_pid
  echo "VLC has exited. Last saved time position: $time_pos seconds."
}

save_progress() {
  local folder="$1"
  local episode_num="$2"
  local time_pos="$3"

  local anime_progress_file="$folder/progress.txt"
  echo "$episode_num" >"$anime_progress_file"
  echo "$time_pos" >>"$anime_progress_file"
}

case "$1" in
download)
  download "$@"
  ;;
playlist)
  if [[ -z $2 ]]; then
    echo "Please specify the folder."
    exit 1
  fi
  create_playlist "$2"
  ;;
watch)
  if [[ -z $2 ]]; then
    echo "Please specify the folder."
    exit 1
  fi
  watch_anime "$2"
  ;;
*)
  print_usage
  ;;
esac
