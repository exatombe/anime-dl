#!/bin/bash

vlc_password="your_vlc_password" # Set your VLC password here
api="https://api.gazes.fr/anime"

pids=()
spinner_pid=""
vlc_pid=""

cleanup() {
  echo "Cleaning up..."

  if [ -n "${pids[*]}" ]; then
    kill "${pids[@]}" >/dev/null 2>&1
  fi

  if [ -n "$vlc_pid" ]; then
    kill $vlc_pid >/dev/null 2>&1
  fi

  stop_spinner

  echo "All processes should be terminated now."
  echo "Exiting gracefully."
  exit 1
}

trap 'cleanup' SIGINT SIGTERM

start_spinner() {
  local message="Downloading $total_episodes episodes..."
  gum spin --spinner dot --title "$message" -- sleep infinity &
  spinner_pid=$!
}

stop_spinner() {
  if [ -n "$spinner_pid" ]; then
    kill $spinner_pid >/dev/null 2>&1
    wait $spinner_pid 2>/dev/null
  fi
}

get_anime() {
  local result=$(curl -s "${api}/animes" | jq -r .data)
  local title=$(echo "$result" | jq -r '.[].title' | fzf)

  if [ -z "$title" ]; then
    echo "No anime selected. Exiting."
    exit 1
  fi

  local anime=$(echo "$result" | jq -r ".[] | select(.title == \"$title\")")
  local anime_id=$(echo "$anime" | jq -r ".id")
  anime=$(curl -s "${api}/animes/${anime_id}")

  echo "$anime"
}

sanitize_filename() {
  echo "$1" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]_-' | tr ' ' '_'
}

download_episode() {
  local anime_title="$1"
  local episode_num="$2"
  local episode_url="$3"
  local folder="$4"

  local sanitized_title=$(sanitize_filename "$anime_title")
  local output_file="$folder/$sanitized_title/episode_${episode_num}.mp4"
  mkdir -p "$folder/$sanitized_title"

  if ffmpeg -loglevel error -i "$episode_url" -c copy "$output_file"; then
    echo "Downloaded episode $episode_num successfully."
    update_playlist "$folder" "$sanitized_title"
  else
    echo "Failed to download episode $episode_num."
  fi
}

update_playlist() {
  local folder="$1"
  local anime_title="$2"
  local playlist_path="$folder/$anime_title/playlist.m3u8"

  echo "#EXTM3U" >"$playlist_path"
  for ep_file in $(ls "$folder/$anime_title"/*.mp4 | sort -V); do
    realpath "$ep_file" >>"$playlist_path"
  done
}

create_playlist() {
  local folder="$1"
  local playlist_path="$folder/playlist.m3u8"

  if [ ! -d "$folder" ]; then
    echo "Folder '$folder' does not exist."
    exit 1
  fi

  echo "#EXTM3U" >"$playlist_path"
  for ep_file in $(ls "$folder"/*.mp4 | sort -V); do
    realpath "$ep_file" >>"$playlist_path"
  done

  echo "Playlist created at $playlist_path"
}

download() {
  local folder="${2:-.}" # Default to current directory if folder not specified
  local anime=$(get_anime)

  if [ -z "$anime" ]; then
    echo "Please select an anime"
    exit 1
  fi

  local anime_id=$(echo "$anime" | jq -r ".data.id")
  local anime_title=$(echo "$anime" | jq -r ".data.title" | sed 's/"/\\"/g')
  local selected_episodes=$(echo "$anime" | jq -r ".data.episodes[].title" | gum choose --no-limit --header "Choose episodes to download")

  if [ -z "$selected_episodes" ]; then
    echo "You must select at least one episode"
    exit 1
  fi

  local lang=$(gum choose --height 4 --header "Language" {vf,vostfr})

  if [ -z "$lang" ]; then
    echo "Language selection required"
    exit 1
  fi

  IFS=$'\n' read -r -d '' -a episodes <<<"$selected_episodes"

  total_episodes=${#episodes[@]}

  start_spinner

  for episode in "${episodes[@]}"; do
    (
      local episode_num=$(echo "$anime" | jq -r ".data.episodes[] | select(.title == \"$episode\") | .num")
      local episode_full=$(curl -s "${api}/animes/${anime_id}/${episode_num}")
      local episode_url=$(echo "$episode_full" | jq -r ".data.${lang}.videoUri // .data.vostfr.videoUri")

      if curl --output /dev/null --silent --head --fail "$episode_url"; then
        download_episode "$anime_title" "$episode_num" "$episode_url" "$folder"
      else
        echo "Episode URL $episode_url not accessible."
      fi
    ) &
    pids+=($!)
  done

  wait "${pids[@]}"
  stop_spinner

  echo "Download completed."
}

print_usage() {
  echo "Usage: $0 download|playlist|watch [folder]"
  exit 1
}

watch_anime() {
  local folder="${1:-.}" # Default to current directory if not specified
  folder=$(realpath "$folder")

  local anime_progress_file="$folder/progress.txt"

  if [ ! -f "$anime_progress_file" ]; then
    echo "No progress file found in $folder. Creating a new one."
    echo "1" >"$anime_progress_file"
    echo "0" >>"$anime_progress_file"
  fi

  local episode_num=$(sed -n '1p' "$anime_progress_file")
  local time_pos=$(sed -n '2p' "$anime_progress_file")

  local anime_title=$(ls "$folder" | head -n 1)
  local playlist_path="$folder/playlist.m3u8"

  if [ ! -f "$playlist_path" ]; then
    echo "Playlist file $playlist_path not found."
    exit 1
  fi

  # Create a temporary file for the updated playlist
  local playlist_tmp=$(mktemp)
  echo "#EXTM3U" >"$playlist_tmp"

  local found_current_episode=false
  for ep_file in $(cat "$playlist_path"); do
    if [ "$found_current_episode" = true ]; then
      echo "$ep_file" >>"$playlist_tmp"
    elif [[ "$ep_file" == *"episode_${episode_num}.mp4"* ]]; then
      echo "$ep_file" >>"$playlist_tmp"
      found_current_episode=true
    fi
  done

  # Start VLC with the HTTP interface enabled and playlist
  vlc --extraintf http --http-password "$vlc_password" "$playlist_tmp" >"$folder/vlc.log" 2>&1 &
  vlc_pid=$!

  while :; do
    if curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json" | jq -e . >/dev/null 2>&1; then
      seek_vlc_to_time "$time_pos"
      break
    fi
    sleep 1
  done

  while :; do
    check_and_reset_vlc_time "$folder"
    # Check if VLC is still running
    if ! kill -0 $vlc_pid 2>/dev/null; then
      echo "VLC process has ended."
      break
    fi
  done

  wait $vlc_pid
  echo "VLC has exited."
}

seek_vlc_to_time() {
  local time_pos="$1"
  if [ -n "$time_pos" ] && [ "$time_pos" -ne 0 ]; then
    curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json?command=seek&val=$time_pos" >/dev/null
  fi
}

check_and_reset_vlc_time() {
  local folder="$1"
  local anime_progress_file="$folder/progress.txt"

  if curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json" | jq -e . >/dev/null 2>&1; then
    local new_time_pos=$(curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json" | jq -r .time)
    local new_episode_num=$(curl -s --user ":$vlc_password" "http://localhost:8080/requests/status.json" | jq -r '.information.category.meta.filename' | grep -o 'episode_[0-9]*' | grep -o '[0-9]*')

    if [ -n "$new_episode_num" ]; then
      if [ "$new_episode_num" != "$(sed -n '1p' "$anime_progress_file")" ]; then
        # Episode has changed, reset time position to 0 for the new episode
        save_progress "$folder" "$new_episode_num" 0
      else
        # Save the current time position for the current episode
        save_progress "$folder" "$new_episode_num" "$new_time_pos"
      fi
    else
      echo "Failed to get episode number from VLC."
    fi
  else
    echo "Unable to connect to VLC HTTP interface. VLC might not have started properly."
    exit 1
  fi
}

save_progress() {
  local folder="$1"
  local episode_num="$2"
  local time_pos="$3"

  local anime_progress_file="$folder/progress.txt"
  echo "$episode_num" >"$anime_progress_file"
  echo "$time_pos" >>"$anime_progress_file"
}

case "$1" in
download)
  download "$@"
  ;;
playlist)
  if [ -z "$2" ]; then
    echo "Please specify the folder."
    exit 1
  fi
  create_playlist "$2"
  ;;
watch)
  watch_anime "$2"
  ;;
*)
  print_usage
  ;;
esac
